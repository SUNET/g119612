//The etsi119612 package implements ETSI 119 612 trust status list. The package is
//primarily meant to be used to create a CertPool for [crypto/x509] Certificate
//validation. The package provides some small number of utilities for introspecting
//trust status lists.

package etsi119612

import (
	"bytes"
	"crypto/x509"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/moov-io/signedxml"
)

const (
	TSLTypeEUListOfLists = "http://uri.etsi.org/TrstSvc/TrustedList/TSLType/EUlistofthelists"
	TSLTypeEUGeneric     = "http://uri.etsi.org/TrstSvc/TrustedList/TSLType/EUgeneric"
)

// A representation of an ETSI 119 612 trust status list. The main struct type StatusList
// is autogenerated from the v2 XML Schema definition.
type TSL struct {
	StatusList TrustStatusListType `xml:"tsl:TrustServiceStatusList"`
	Source     string
	Signed     bool
	Signer     x509.Certificate
	Referenced []*TSL
}

func (tsl *TSL) NumberOfTrustServiceProviders() int {
	if tsl == nil || tsl.StatusList.TslTrustServiceProviderList == nil {
		return 0
	}
	return len(tsl.StatusList.TslTrustServiceProviderList.TslTrustServiceProvider)
}

func (tsl *TSL) SchemeOperatorName() string {
	if tsl == nil || tsl.StatusList.TslSchemeInformation == nil {
		return "Unknown scheme operator"
	}
	return FindByLanguage(tsl.StatusList.TslSchemeInformation.TslSchemeOperatorName, "en", "Unknown scheme operator")
}

func (tsl *TSL) String() string {
	if tsl == nil {
		return "<nil TSL>"
	}
	return fmt.Sprintf("TSL[Source: %s] by %s with %d trust service providers", tsl.Source, tsl.SchemeOperatorName(), tsl.NumberOfTrustServiceProviders())
}

// CleanCerts trims whitespace from all certificates in the TSL.
func (tsl *TSL) CleanCerts() {
	tsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
		if svc.TslServiceInformation != nil && svc.TslServiceInformation.TslServiceDigitalIdentity != nil {
			for i := range svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId {
				cert := svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId[i].X509Certificate
				svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId[i].X509Certificate = strings.TrimSpace(cert)
			}
		}
	})
}

func (tsl *TSL) IsLOTL() bool {
	return tsl != nil && tsl.StatusList.TslSchemeInformation != nil &&
		(tsl.StatusList.TslSchemeInformation.TslTSLType == TSLTypeEUListOfLists)
}

func (tsl *TSL) IsNationalTSL() bool {
	return tsl != nil && tsl.StatusList.TslSchemeInformation != nil &&
		(tsl.StatusList.TslSchemeInformation.TslTSLType == TSLTypeEUGeneric)
}

func FetchTSLBytes(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	fmt.Println(url)
	if bytes.Contains(bodyBytes, []byte("Signature>")) {

		// lets try to validate a signature if we can
		validator, err := signedxml.NewValidator(string(bodyBytes))
		if err == nil {
			validator.SetReferenceIDAttribute("Id")
			xml, err := validator.ValidateReferences()
			if err == nil {
				bodyBytes = []byte(xml[0])
				_ = validator.SigningCert()
			} else {
				return nil, err
			}
		} else {
			return nil, err
		}
	}
	fmt.Println(url)

	//TODO:allows the certificates without a signature -- fix
	return bodyBytes, err
}

func UnmarshalCleanCerts(bodyBytes []byte, url string) (*TSL, error) {
	t := TSL{Source: url, StatusList: TrustStatusListType{}}
	t.Signed = true
	err := xml.Unmarshal(bodyBytes, &t.StatusList)
	if err != nil {
		return nil, err
	}
	//mb do smth else with it later: does not work on lotl
	//t.cleanCerts()
	return &t, nil
}

func FetchPontersToOtherListTSL(tsl *TSL) ([]string, error) {
	queuePointers := []string{}

	TslPointersToOtherTSLList := tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL.TslOtherTSLPointer

	fmt.Printf("%v", len(TslPointersToOtherTSLList))
	for _, i := range TslPointersToOtherTSLList {
		queuePointers = append(queuePointers, i.TSLLocation)
	}
	return queuePointers, nil
}

// Create a TSL object from a URL. The URL is fetched with [net/http], parsed and unmarshalled
// into the object structure.
func FetchTSL(url string) (*TSL, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	t := TSL{Source: url, StatusList: TrustStatusListType{}}
	log.Debugf("g119612: Fetched %d bytes from %s\n", len(bodyBytes), url)

	if bytes.Contains(bodyBytes, []byte("Signature>")) {
		t.Signed = true
		// lets try to validate a signature if we can
		validator, err := signedxml.NewValidator(string(bodyBytes))
		if err == nil {
			validator.SetReferenceIDAttribute("Id")
			xml, err := validator.ValidateReferences()
			if err == nil {
				bodyBytes = []byte(xml[0])
				t.Signer = validator.SigningCert()
			} else {
				return nil, err
			}
		} else {
			return nil, err
		}
	}

	err = xml.Unmarshal(bodyBytes, &t.StatusList)
	if err != nil {
		return nil, err
	}

	t.CleanCerts()
	t.dereferencePointersToOtherTSL()
	log.Infof("g119612: Parsed TSL from %s with %d trust service providers\n", url, t.NumberOfTrustServiceProviders())

	return &t, nil
}

func (tsl *TSL) AddReferencedTSL(ref *TSL) {
	if tsl.Referenced == nil {
		tsl.Referenced = []*TSL{}
	}
	tsl.Referenced = append(tsl.Referenced, ref)
}

// Dereference pointers to other TSLs found in the TSL, fetching and adding them to the Referenced list.

func (tsl *TSL) dereferencePointersToOtherTSL() {
	if tsl.StatusList.TslSchemeInformation == nil || tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL == nil {
		return
	}
	for _, p := range tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL.TslOtherTSLPointer {
		refTsl, err := FetchTSL(p.TSLLocation)
		if err == nil {
			tsl.AddReferencedTSL(refTsl)
		}
	}
}

// WithTrustServices walks a TSL, calling cb once for each TrustService found. The TrustServiceProvider is provided as a first
// argument to the callback
func (tsl *TSL) WithTrustServices(cb func(*TSPType, *TSPServiceType)) {
	if tsl.StatusList.TslTrustServiceProviderList == nil {
		return
	}
	for _, tsp := range tsl.StatusList.TslTrustServiceProviderList.TslTrustServiceProvider {
		if tsp != nil && tsp.TslTSPServices != nil {
			for _, svc := range tsp.TslTSPServices.TslTSPService {
				cb(tsp, svc)
			}
		}
	}
}

// Generate a [crypto/xml.CertPool] object from the TSL.
func (tsl *TSL) ToCertPool(policy *TSPServicePolicy) *x509.CertPool {
	pool := x509.NewCertPool()
	tsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
		svc.withCertificates(func(cert *x509.Certificate) {
			// Only add cert if policy is satisfied
			if tsp.Validate(svc, []*x509.Certificate{cert}, policy) == nil {
				pool.AddCert(cert)
			}
		})
	})
	return pool
}
